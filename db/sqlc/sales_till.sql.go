// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: sales_till.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSales_till = `-- name: CreateSales_till :one
INSERT INTO sales_till (
    till_num, teller, supervisor, branch, open_cash, close_time, close_cash, close_summary
) VALUES (
     $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING till_num, teller, supervisor, branch, open_time, open_cash, close_time, close_cash, close_summary
`

type CreateSales_tillParams struct {
	TillNum      int64              `json:"till_num"`
	Teller       pgtype.Text        `json:"teller"`
	Supervisor   pgtype.Text        `json:"supervisor"`
	Branch       pgtype.Text        `json:"branch"`
	OpenCash     float64            `json:"open_cash"`
	CloseTime    pgtype.Timestamptz `json:"close_time"`
	CloseCash    pgtype.Float8      `json:"close_cash"`
	CloseSummary []byte             `json:"close_summary"`
}

func (q *Queries) CreateSales_till(ctx context.Context, arg CreateSales_tillParams) (SalesTill, error) {
	row := q.db.QueryRow(ctx, createSales_till,
		arg.TillNum,
		arg.Teller,
		arg.Supervisor,
		arg.Branch,
		arg.OpenCash,
		arg.CloseTime,
		arg.CloseCash,
		arg.CloseSummary,
	)
	var i SalesTill
	err := row.Scan(
		&i.TillNum,
		&i.Teller,
		&i.Supervisor,
		&i.Branch,
		&i.OpenTime,
		&i.OpenCash,
		&i.CloseTime,
		&i.CloseCash,
		&i.CloseSummary,
	)
	return i, err
}

const deleteSales_till = `-- name: DeleteSales_till :exec
DELETE FROM sales_till
WHERE till_num = $1
`

func (q *Queries) DeleteSales_till(ctx context.Context, tillNum int64) error {
	_, err := q.db.Exec(ctx, deleteSales_till, tillNum)
	return err
}

const getSales_till = `-- name: GetSales_till :one
SELECT till_num, teller, supervisor, branch, open_time, open_cash, close_time, close_cash, close_summary FROM sales_till
WHERE till_num = $1 LIMIT 1
`

func (q *Queries) GetSales_till(ctx context.Context, tillNum int64) (SalesTill, error) {
	row := q.db.QueryRow(ctx, getSales_till, tillNum)
	var i SalesTill
	err := row.Scan(
		&i.TillNum,
		&i.Teller,
		&i.Supervisor,
		&i.Branch,
		&i.OpenTime,
		&i.OpenCash,
		&i.CloseTime,
		&i.CloseCash,
		&i.CloseSummary,
	)
	return i, err
}

const listSales_till = `-- name: ListSales_till :many
SELECT till_num, teller, supervisor, branch, open_time, open_cash, close_time, close_cash, close_summary FROM sales_till
WHERE till_num = $1
ORDER BY teller
LIMIT $2
OFFSET $3
`

type ListSales_tillParams struct {
	TillNum int64 `json:"till_num"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListSales_till(ctx context.Context, arg ListSales_tillParams) ([]SalesTill, error) {
	rows, err := q.db.Query(ctx, listSales_till, arg.TillNum, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SalesTill{}
	for rows.Next() {
		var i SalesTill
		if err := rows.Scan(
			&i.TillNum,
			&i.Teller,
			&i.Supervisor,
			&i.Branch,
			&i.OpenTime,
			&i.OpenCash,
			&i.CloseTime,
			&i.CloseCash,
			&i.CloseSummary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSales_till = `-- name: UpdateSales_till :one
UPDATE sales_till
SET teller = $2,
    supervisor = $3,
    branch = $4,
    open_cash = $5,
    close_time = $6,
    close_time = $7,
    close_cash = $8,
    close_summary = $9
WHERE till_num = $1
RETURNING till_num, teller, supervisor, branch, open_time, open_cash, close_time, close_cash, close_summary
`

type UpdateSales_tillParams struct {
	TillNum      int64              `json:"till_num"`
	Teller       pgtype.Text        `json:"teller"`
	Supervisor   pgtype.Text        `json:"supervisor"`
	Branch       pgtype.Text        `json:"branch"`
	OpenCash     float64            `json:"open_cash"`
	CloseTime    pgtype.Timestamptz `json:"close_time"`
	CloseTime_2  pgtype.Timestamptz `json:"close_time_2"`
	CloseCash    pgtype.Float8      `json:"close_cash"`
	CloseSummary []byte             `json:"close_summary"`
}

func (q *Queries) UpdateSales_till(ctx context.Context, arg UpdateSales_tillParams) (SalesTill, error) {
	row := q.db.QueryRow(ctx, updateSales_till,
		arg.TillNum,
		arg.Teller,
		arg.Supervisor,
		arg.Branch,
		arg.OpenCash,
		arg.CloseTime,
		arg.CloseTime_2,
		arg.CloseCash,
		arg.CloseSummary,
	)
	var i SalesTill
	err := row.Scan(
		&i.TillNum,
		&i.Teller,
		&i.Supervisor,
		&i.Branch,
		&i.OpenTime,
		&i.OpenCash,
		&i.CloseTime,
		&i.CloseCash,
		&i.CloseSummary,
	)
	return i, err
}
